import graphviz

# Operadores y su precedencia
OPERATORS = {'|', '.', '*', '+', '?'}
PRECEDENCE = {'|': 1, '.': 2, '*': 3, '+': 3, '?': 3}

# Paso 1: Convertir ER infija a postfija (Shunting Yard)
def insert_concat(regex):
    output = []
    prev = None
    for token in regex:
        if prev and (prev.isalnum() or prev in {'*', '+', '?', ')'}) and (token.isalnum() or token == '('):
            output.append('.')
        output.append(token)
        prev = token
    return ''.join(output)

def shunting_yard(regex):
    regex = insert_concat(regex) + "#."  # Se agrega el #
    output, stack = [], []
    for token in regex:
        if token.isalnum() or token == '#':
            output.append(token)
        elif token == '(':
            stack.append(token)
        elif token == ')':
            while stack and stack[-1] != '(':
                output.append(stack.pop())
            stack.pop()
        elif token in OPERATORS:
            while stack and stack[-1] in OPERATORS and PRECEDENCE[stack[-1]] >= PRECEDENCE[token]:
                output.append(stack.pop())
            stack.append(token)
    while stack:
        output.append(stack.pop())
    return ''.join(output)

# Paso 2: Construcción del Árbol Sintáctico con firstpos, lastpos y nullable
class ASTNode:
    def __init__(self, value, left=None, right=None, position=None):
        self.value = value
        self.left = left
        self.right = right
        self.position = position
        self.nullable = False
        self.firstpos = set()
        self.lastpos = set()

def build_syntax_tree(postfix):
    stack = []
    position = 1
    leaf_positions = {}

    for token in postfix:
        if token.isalnum() or token == '#':
            node = ASTNode(token, position=position)
            node.firstpos.add(position)
            node.lastpos.add(position)
            leaf_positions[position] = node
            stack.append(node)
            position += 1
        elif token in OPERATORS:
            if token in {'*', '+', '?'}:
                child = stack.pop()
                node = ASTNode(token, left=child)
                if token in {'*', '?'}:
                    node.nullable = True
                node.firstpos = child.firstpos
                node.lastpos = child.lastpos
            else:  # Concatenación o unión
                right, left = stack.pop(), stack.pop()
                node = ASTNode(token, left, right)
                if token == '.':
                    node.nullable = left.nullable and right.nullable
                    node.firstpos = left.firstpos if not left.nullable else left.firstpos | right.firstpos
                    node.lastpos = right.lastpos if not right.nullable else right.lastpos | left.lastpos
                elif token == '|':
                    node.nullable = left.nullable or right.nullable
                    node.firstpos = left.firstpos | right.firstpos
                    node.lastpos = left.lastpos | right.lastpos
            stack.append(node)

    return stack[-1], leaf_positions

# Paso 3: Calcular followpos
def compute_followpos(root, leaf_positions):
    followpos = {pos: set() for pos in leaf_positions}
    
    def traverse(node):
        if node is None:
            return

        if node.value == '.':
            for pos in node.left.lastpos:
                followpos[pos] |= node.right.firstpos
        elif node.value in {'*', '+'}:
            for pos in node.lastpos:
                followpos[pos] |= node.firstpos

        traverse(node.left)
        traverse(node.right)

    traverse(root)
    return followpos

# Paso 4: Construcción del AFD usando followpos
def generate_afd_visualization(followpos, leaf_positions):
    afd_graph = graphviz.Digraph(format="png", name="AFD_Directo")
    
    estados = {}
    estado_inicial = frozenset(leaf_positions[1].firstpos)  # Estado inicial basado en firstpos(raíz)
    estados[estado_inicial] = "A"
    pendientes = [estado_inicial]
    transiciones = {}
    nombre_estado = iter("ABCDEFGHIJKLMNOPQRSTUVWXYZ")

    while pendientes:
        estado = pendientes.pop(0)  # Sacamos el estado a procesar
        nombre_actual = estados[estado]
        afd_graph.node(nombre_actual, label=nombre_actual, shape="circle")

        movimientos = {}
        for pos in estado:
            if leaf_positions[pos].value != "#":
                simbolo = leaf_positions[pos].value
                if simbolo not in movimientos:
                    movimientos[simbolo] = set()
                movimientos[simbolo] |= followpos[pos]

        for simbolo, destino in movimientos.items():
            destino_frozen = frozenset(destino)
            if destino_frozen not in estados:
                nuevo_nombre = next(nombre_estado)
                estados[destino_frozen] = nuevo_nombre
                pendientes.append(destino_frozen)
            afd_graph.edge(nombre_actual, estados[destino_frozen], label=simbolo)

    # Identificar estados finales (contienen el #)
    for estado, nombre in estados.items():
        if any(leaf_positions[pos].value == "#" for pos in estado):
            afd_graph.node(nombre, shape="doublecircle")  # Estado final

    afd_graph.render("afd", format="png")

# Generar visualización del AST con Graphviz
def generate_ast_visualization(root):
    ast_graph = graphviz.Digraph(format="png")

    def draw_ast(node, parent_id=None):
        if node is None:
            return
        node_id = str(id(node))
        label = f"{node.value}" if node.position is None else f"{node.value} ({node.position})"
        ast_graph.node(node_id, label, shape="ellipse", style="filled", fillcolor="lightblue")
        if parent_id:
            ast_graph.edge(parent_id, node_id)
        draw_ast(node.left, node_id)
        draw_ast(node.right, node_id)

    draw_ast(root)
    ast_graph.render("ast", format="png")

# Generar visualización completa
def generate_visualization(regex):
    postfix = shunting_yard(regex)
    root, leaf_positions = build_syntax_tree(postfix)
    followpos = compute_followpos(root, leaf_positions)

    generate_ast_visualization(root)
    generate_afd_visualization(followpos, leaf_positions)

    with open("visualization.html", "w") as f:
        f.write("""
        <html>
        <head><title>Visualización del AST y AFD</title></head>
        <body>
            <h2>Árbol Sintáctico</h2>
            <img src='ast.png' alt='AST' style='max-width:100%; height:auto;'>
            <h2>Autómata Finito Determinista (AFD)</h2>
            <img src='afd.png' alt='AFD' style='max-width:100%; height:auto;'>
        </body>
        </html>
        """)
    print("Se generó visualization.html correctamente.")

# Entrada desde la terminal
if __name__ == "__main__":
    regex = input("Ingrese la expresión regular: ")
    generate_visualization(regex)
